## Day2

#### 几个地址的解释

一个地址代表着一个字节的内存空间

| 地址         | 解释                                                         |
| ------------ | ------------------------------------------------------------ |
| `0x7c00`     | 规定，引导扇区开始执行的地址必须在内存的`0x7c00`处，引导扇区占据的地址范围为`0x7c00 ~ 0x7e00`，其中`0x7e00 = 0x7c00 + 512(0x200)` |
| `0x8200`     | 软盘数据存储的地址，从第一个柱面第二个扇区读入的数据全部都被保存到了此处。`0x8000 ~ 0x8200`预留给引导扇区 |
| `0x2600`     | IMG磁盘中`0x2600`的位置存储着系统文件`.sys`的文件名          |
| `0x4200`     | IMG磁盘中`0x4200`的位置存储着系统文件的内容                  |
| `0xc200`     | 将IMG磁盘读入到`0x8000`位置后（此处包括了引导扇区的`512`字节），系统文件的内容就存储于`0xc200 = 0x8000 + 0x4200`。也就是说，`asmhead.nas`的内容应该被存放在`0xc200`的位置 |
| `0x0ff0`     | 从内存空闲区选择的一块内存地址，用于存储`BOOTINFO`相关数据   |
| `0xa000`     | VGA 显卡， 320x200x8位彩色模式下，显存地址为`0xa000`         |
| `0x00010000` | 1M内存地址，用于存放磁盘中的系统文件，范围为`0x10000 ~ 0x15800`，其中`0x15800 = 0x10000 + 512 x 18 x 2 (0x4800)` |
| `0x00270000` | 从1M以后的内存空闲区选择的一块内存地址，用于存储GDT          |
| `0x0026f800` | 从1M以后的内存空闲区选择的一块内存地址，用于存储IDT          |
| `0x00280000` | 从1M以后的内存空闲区选择的一块内存地址，用于存放`bootpack`文件中内容 |
| `0x003c0000` | 用于存放内存管理数据结构的地址，范围为`0x003c0000 ~ `        |

#### day1读取引导扇区到那儿了【TODO】



## Day8

#### `asmhead.nas`内容简介

1. 启动显卡，记录各种数据以备候用
2. 开启保护模式，使CPU可以访问1M以后的内存
   1. 关闭所有的PIC中断
   2. 使能A20GATE
   3. 切换到保护模式，禁用分页，并刷新寄存器值
3. 将磁盘中的系统复制到1M以后的地址
   1. `bootpack`存放到`0x00280000`，源地址不知，是工具拼接时生成的，此处直接用`bootpack`文件名获取
   2. 启动扇区从`0x7c000`复制到1M地址处
   3. 剩下的内容从`0x8200`处复制到`0x00010200`处，其中`0x00010200 = 0x0001000 + 0x0200(512)`
4. 启动`bootpack`



## Day9

#### 内存大小计算过程

1. 确认CPU型号是否为i486，如果是i386则不必关闭缓存
   1. 修改eflags寄存器的ac(18)位
   2. 再次读取eflags的ac位，如果被自动置为0表示不是i486CPU
   3. 还原eflags寄存器
2. 设置CR0寄存器的cd(30)位为1，表示禁用cache
3. 开始计算内存大小
   1. 从`0x00400000`到`0xbfffffff`，每次查看最后4个字节是否为内存
   2. 向地址中写入数据，然后反转，检查数据是否符合预期
   3. 再反转数据，检查数据是否符合预期
   4. 还原地址中数据的值
4. 还原CR0寄存器



#### 内存管理数据结构大小

设置为4090后，`memman`的总大小为`4090 * (4 + 4) + 4 * 4 = 0x7fe0`，距离`32KB(0x8000)`仅差了`0x0010`也就是16个字节，2个`freeinfo`数据结构的大小，那为什么不直接设为4092呢？





## Day10

